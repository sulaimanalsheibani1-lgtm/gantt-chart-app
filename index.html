// ...existing code...
<script>
    // Project data structure
    let project = {
        name: 'Sample Project',
        startDate: new Date(),
        tasks: [],
        nextId: 1
    };

    let selectedTaskId = null;
    let zoomLevel = 30; // pixels per day

    // Initialize the application
    function init() {
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('projectStartDate').value = today;
        createSampleProject();
        renderProject();
    }

    // Create sample project with WBS structure
    function createSampleProject() {
        project = {
            name: 'Intranet Project',
            startDate: new Date(),
            tasks: [
                // ...same as before...
            ],
            nextId: 17
        };
        calculateSchedule();
    }

    // Only return tasks that are visible (expanded in hierarchy)
    function getVisibleTasks() {
        const visible = [];
        const stack = [];
        project.tasks.forEach(task => {
            // Only show if all parents are expanded
            let show = true;
            for (let i = 0; i < stack.length; i++) {
                if (!stack[i].expanded) {
                    show = false;
                    break;
                }
            }
            if (show) visible.push(task);
            if (task.isSummary) stack[task.level] = task;
            stack.length = task.level + 1;
        });
        return visible;
    }

    // Calculate project schedule
    function calculateSchedule() {
        // Reset all dates
        project.tasks.forEach(task => {
            if (!task.isSummary) {
                task.start = null;
                task.finish = null;
            }
        });

        // Forward pass
        let changed = true;
        while (changed) {
            changed = false;
            project.tasks.forEach(task => {
                if (!task.isSummary) {
                    let duration = parseInt(task.duration) || 0;
                    if (duration < 0) duration = 0;
                    task.duration = duration;
                    if (!task.predecessor || task.predecessor === '') {
                        if (!task.start) {
                            task.start = new Date(project.startDate);
                            task.finish = duration === 0 ? new Date(task.start) : addWorkDays(task.start, duration - 1);
                            changed = true;
                        }
                    } else {
                        const predIds = task.predecessor.split(',').map(p => p.trim()).filter(Boolean);
                        let maxFinish = null;
                        predIds.forEach(predId => {
                            const pred = project.tasks.find(t => t.id == predId);
                            if (pred && pred.finish) {
                                if (!maxFinish || pred.finish > maxFinish) {
                                    maxFinish = new Date(pred.finish);
                                }
                            }
                        });
                        if (maxFinish && !task.start) {
                            task.start = addWorkDays(maxFinish, 1);
                            task.finish = duration === 0 ? new Date(task.start) : addWorkDays(task.start, duration - 1);
                            changed = true;
                        }
                    }
                }
            });
        }
        updateSummaryTasks();
        calculateCriticalPath();
    }

    // Update summary task dates
    function updateSummaryTasks() {
        for (let level = 3; level >= 0; level--) {
            project.tasks.forEach(task => {
                if (task.isSummary && task.level === level) {
                    const children = getChildTasks(task);
                    if (children.length > 0) {
                        let minStart = null;
                        let maxFinish = null;
                        children.forEach(child => {
                            if (child.start && (!minStart || child.start < minStart)) {
                                minStart = new Date(child.start);
                            }
                            if (child.finish && (!maxFinish || child.finish > maxFinish)) {
                                maxFinish = new Date(child.finish);
                            }
                        });
                        task.start = minStart;
                        task.finish = maxFinish;
                        if (minStart && maxFinish) {
                            task.duration = getWorkDays(minStart, maxFinish);
                        }
                    }
                }
            });
        }
    }

    // Get child tasks of a summary task
    function getChildTasks(summaryTask) {
        return project.tasks.filter(
            t => t.level === summaryTask.level + 1 && t.wbs.startsWith(summaryTask.wbs + '.')
        );
    }

    // Calculate critical path
    function calculateCriticalPath() {
        let projectEnd = null;
        project.tasks.forEach(task => {
            if (task.finish && (!projectEnd || task.finish > projectEnd)) {
                projectEnd = task.finish;
            }
        });
        project.tasks.forEach(task => { task.isCritical = false; });
        const endTasks = project.tasks.filter(task =>
            !task.isSummary && task.finish && projectEnd && task.finish.getTime() === projectEnd.getTime()
        );
        endTasks.forEach(task => markCriticalPath(task));
    }

    function markCriticalPath(task) {
        task.isCritical = true;
        if (task.predecessor) {
            const predIds = task.predecessor.split(',').map(p => p.trim());
            predIds.forEach(predId => {
                const pred = project.tasks.find(t => t.id == predId);
                if (pred && !pred.isCritical) markCriticalPath(pred);
            });
        }
    }

    // Add work days (skip weekends)
    function addWorkDays(startDate, days) {
        let date = new Date(startDate);
        let daysAdded = 0;
        while (daysAdded < days) {
            date.setDate(date.getDate() + 1);
            if (date.getDay() !== 0 && date.getDay() !== 6) daysAdded++;
        }
        return date;
    }

    // Get work days between two dates
    function getWorkDays(startDate, endDate) {
        let count = 0;
        let date = new Date(startDate);
        while (date <= endDate) {
            if (date.getDay() !== 0 && date.getDay() !== 6) count++;
            date.setDate(date.getDate() + 1);
        }
        return count;
    }

    // Render the entire project
    function renderProject() {
        renderTaskList();
        renderGanttChart();
        updateStatusBar();
    }

    // Render task list (only visible tasks)
    function renderTaskList() {
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
        getVisibleTasks().forEach(task => {
            const row = document.createElement('div');
            row.className = 'task-row';
            if (task.isSummary) row.className += ' summary';
            if (task.id === selectedTaskId) row.className += ' selected';
            row.onclick = () => selectTask(task.id);

            // ID
            const idCell = document.createElement('div');
            idCell.className = 'task-id';
            idCell.textContent = task.id;
            row.appendChild(idCell);

            // WBS
            const wbsCell = document.createElement('div');
            wbsCell.className = 'task-wbs';
            wbsCell.textContent = task.wbs;
            row.appendChild(wbsCell);

            // Name
            const nameCell = document.createElement('div');
            nameCell.className = 'task-name';
            for (let i = 0; i < task.level; i++) {
                const spacer = document.createElement('span');
                spacer.className = 'indent-spacer';
                nameCell.appendChild(spacer);
            }
            if (task.isSummary) {
                const expandIcon = document.createElement('span');
                expandIcon.innerHTML = 'â–¼';
                expandIcon.className = 'expand-icon';
                if (!task.expanded) expandIcon.className += ' collapsed';
                expandIcon.onclick = (e) => {
                    e.stopPropagation();
                    toggleTask(task.id);
                };
                nameCell.appendChild(expandIcon);
            }
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = task.name;
            nameInput.onchange = (e) => updateTaskField(task.id, 'name', e.target.value);
            nameCell.appendChild(nameInput);
            row.appendChild(nameCell);

            // Duration
            const durationCell = document.createElement('div');
            durationCell.className = 'task-duration';
            if (!task.isSummary) {
                const durationInput = document.createElement('input');
                durationInput.type = 'number';
                durationInput.min = 0;
                durationInput.value = task.duration;
                durationInput.onchange = (e) => {
                    let val = parseInt(e.target.value) || 0;
                    if (val < 0) val = 0;
                    updateTaskField(task.id, 'duration', val);
                };
                durationCell.appendChild(durationInput);
            } else {
                durationCell.textContent = task.duration ? task.duration + ' days' : '';
            }
            row.appendChild(durationCell);

            // Start
            const startCell = document.createElement('div');
            startCell.className = 'task-start';
            const startInput = document.createElement('input');
            startInput.type = 'text';
            startInput.value = task.start ? formatDate(task.start) : '';
            startInput.readOnly = true;
            startCell.appendChild(startInput);
            row.appendChild(startCell);

            // Finish
            const finishCell = document.createElement('div');
            finishCell.className = 'task-finish';
            const finishInput = document.createElement('input');
            finishInput.type = 'text';
            finishInput.value = task.finish ? formatDate(task.finish) : '';
            finishInput.readOnly = true;
            finishCell.appendChild(finishInput);
            row.appendChild(finishCell);

            // Predecessor
            const predCell = document.createElement('div');
            predCell.className = 'task-predecessor';
            if (!task.isSummary) {
                const predInput = document.createElement('input');
                predInput.type = 'text';
                predInput.value = task.predecessor || '';
                predInput.onchange = (e) => updateTaskField(task.id, 'predecessor', e.target.value);
                predCell.appendChild(predInput);
            }
            row.appendChild(predCell);

            taskList.appendChild(row);
        });
    }

    // Render Gantt chart (only visible tasks)
    function renderGanttChart() {
        renderGanttHeader();
        renderGanttGrid();
        renderGanttBars();
        renderGanttLinks();
    }

    function renderGanttHeader() {
        const header = document.getElementById('ganttHeader');
        header.innerHTML = '';
        let minDate = new Date(project.startDate);
        let maxDate = new Date(project.startDate);
        project.tasks.forEach(task => {
            if (task.finish && task.finish > maxDate) maxDate = new Date(task.finish);
        });
        maxDate = addWorkDays(maxDate, 10);
        const monthHeader = document.createElement('div');
        monthHeader.className = 'month-header';
        const dayHeader = document.createElement('div');
        dayHeader.className = 'day-header';
        let currentDate = new Date(minDate);
        let currentMonth = -1;
        let monthWidth = 0;
        while (currentDate <= maxDate) {
            const dayCell = document.createElement('div');
            dayCell.className = 'day-cell';
            if (currentDate.getDay() === 0 || currentDate.getDay() === 6) dayCell.className += ' weekend';
            dayCell.textContent = currentDate.getDate();
            dayCell.style.width = zoomLevel + 'px';
            dayHeader.appendChild(dayCell);
            if (currentDate.getMonth() !== currentMonth) {
                if (currentMonth !== -1) {
                    const monthCell = document.createElement('div');
                    monthCell.className = 'month-cell';
                    monthCell.textContent = getMonthName(currentMonth) + ' ' + currentDate.getFullYear();
                    monthCell.style.width = monthWidth + 'px';
                    monthHeader.appendChild(monthCell);
                }
                currentMonth = currentDate.getMonth();
                monthWidth = 0;
            }
            monthWidth += zoomLevel;
            currentDate.setDate(currentDate.getDate() + 1);
        }
        if (monthWidth > 0) {
            const monthCell = document.createElement('div');
            monthCell.className = 'month-cell';
            monthCell.textContent = getMonthName(currentMonth) + ' ' + currentDate.getFullYear();
            monthCell.style.width = monthWidth + 'px';
            monthHeader.appendChild(monthCell);
        }
        header.appendChild(monthHeader);
        header.appendChild(dayHeader);
    }

    function renderGanttGrid() {
        const grid = document.getElementById('ganttGrid');
        grid.innerHTML = '';
        let minDate = new Date(project.startDate);
        let maxDate = new Date(project.startDate);
        project.tasks.forEach(task => {
            if (task.finish && task.finish > maxDate) maxDate = new Date(task.finish);
        });
        maxDate = addWorkDays(maxDate, 10);
        let currentDate = new Date(minDate);
        while (currentDate <= maxDate) {
            const column = document.createElement('div');
            column.className = 'grid-column';
            if (currentDate.getDay() === 0 || currentDate.getDay() === 6) column.className += ' weekend';
            column.style.width = zoomLevel + 'px';
            grid.appendChild(column);
            currentDate.setDate(currentDate.getDate() + 1);
        }
    }

    function renderGanttBars() {
        const rows = document.getElementById('ganttRows');
        rows.innerHTML = '';
        getVisibleTasks().forEach((task, idx) => {
            const row = document.createElement('div');
            row.className = 'gantt-row';
            if (task.isSummary) row.className += ' summary';
            if (task.start && task.finish) {
                const bar = document.createElement('div');
                bar.className = 'gantt-bar';
                if (task.isSummary) bar.className += ' summary';
                else if (task.duration === 0) bar.className += ' milestone';
                else if (task.isCritical) bar.className += ' critical';
                const startOffset = getDaysDiff(project.startDate, task.start) * zoomLevel;
                const width = task.duration === 0 ? 16 : getDaysDiff(task.start, task.finish) * zoomLevel;
                bar.style.left = startOffset + 'px';
                bar.style.width = width + 'px';
                if (task.duration > 0 && !task.isSummary) bar.textContent = task.name.substring(0, 20);
                row.appendChild(bar);
            }
            rows.appendChild(row);
        });
    }

    function renderGanttLinks() {
        const svg = document.getElementById('ganttLinks');
        svg.innerHTML = '';
        const visibleTasks = getVisibleTasks();
        visibleTasks.forEach((task, taskIndex) => {
            if (task.predecessor && task.start) {
                const predIds = task.predecessor.split(',').map(p => p.trim());
                predIds.forEach(predId => {
                    const pred = project.tasks.find(t => t.id == predId);
                    if (pred && pred.finish) {
                        const predIndex = visibleTasks.indexOf(pred);
                        if (predIndex === -1) return; // Only draw if both are visible
                        const x1 = getDaysDiff(project.startDate, pred.finish) * zoomLevel;
                        const y1 = predIndex * 37 + 18;
                        const x2 = getDaysDiff(project.startDate, task.start) * zoomLevel;
                        const y2 = taskIndex * 37 + 18;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${x1} ${y1} L ${x1 + 10} ${y1} L ${x1 + 10} ${y2} L ${x2} ${y2}`;
                        path.setAttribute('d', d);
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.className.baseVal = 'gantt-link';
                        if (task.isCritical && pred.isCritical) g.className.baseVal += ' critical';
                        g.appendChild(path);
                        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        arrow.setAttribute('points', `${x2},${y2} ${x2-5},${y2-3} ${x2-5},${y2+3}`);
                        arrow.setAttribute('fill', task.isCritical && pred.isCritical ? 'var(--critical-path)' : 'var(--text-secondary)');
                        g.appendChild(arrow);
                        svg.appendChild(g);
                    }
                });
            }
        });
    }

    // Update status bar
    function updateStatusBar() {
        document.getElementById('taskCount').textContent = project.tasks.length;
        if (project.tasks.length > 0 && project.tasks[0].finish) {
            const duration = getWorkDays(project.startDate, project.tasks[0].finish);
            document.getElementById('projectDuration').textContent = duration + ' days';
            document.getElementById('projectDates').textContent =
                `Start: ${formatDate(project.startDate)} | End: ${formatDate(project.tasks[0].finish)}`;
        } else {
            document.getElementById('projectDuration').textContent = '0 days';
            document.getElementById('projectDates').textContent = 'Start: -- | End: --';
        }
    }

    // Task operations
    function selectTask(taskId) {
        selectedTaskId = taskId;
        renderTaskList();
    }

    function toggleTask(taskId) {
        const task = project.tasks.find(t => t.id === taskId);
        if (task) {
            task.expanded = !task.expanded;
            renderProject();
        }
    }

    function updateTaskField(taskId, field, value) {
        const task = project.tasks.find(t => t.id === taskId);
        if (task) {
            if (field === 'duration') {
                value = parseInt(value) || 0;
                if (value < 0) value = 0;
            }
            if (field === 'predecessor') {
                // Validate predecessor: must be existing task id, not self, not circular
                const predIds = value.split(',').map(p => p.trim()).filter(Boolean);
                for (const predId of predIds) {
                    if (parseInt(predId) === task.id) {
                        alert('Task cannot be predecessor of itself.');
                        return;
                    }
                    if (!project.tasks.find(t => t.id == predId)) {
                        alert('Invalid predecessor id: ' + predId);
                        return;
                    }
                }
            }
            task[field] = value;
            calculateSchedule();
            renderProject();
        }
    }

    function addTask() {
        let insertLevel = 1;
        let insertIndex = project.tasks.length;
        if (selectedTaskId) {
            const selectedTask = project.tasks.find(t => t.id === selectedTaskId);
            insertLevel = selectedTask ? selectedTask.level : 1;
            insertIndex = project.tasks.findIndex(t => t.id === selectedTaskId) + 1;
        }
        const newTask = {
            id: project.nextId++,
            wbs: '', // will be set below
            name: 'New Task',
            duration: 1,
            start: null,
            finish: null,
            predecessor: '',
            level: insertLevel,
            isSummary: false,
            expanded: true
        };
        project.tasks.splice(insertIndex, 0, newTask);
        updateWBS();
        calculateSchedule();
        renderProject();
    }

    function deleteTask() {
        if (selectedTaskId) {
            project.tasks = project.tasks.filter(t => t.id !== selectedTaskId);
            selectedTaskId = null;
            updateWBS();
            calculateSchedule();
            renderProject();
        }
    }

    function indentTask() {
        if (selectedTaskId) {
            const idx = project.tasks.findIndex(t => t.id === selectedTaskId);
            if (idx > 0 && project.tasks[idx].level < 3) {
                project.tasks[idx].level++;
                updateWBS();
                calculateSchedule();
                renderProject();
            }
        }
    }

    function outdentTask() {
        if (selectedTaskId) {
            const idx = project.tasks.findIndex(t => t.id === selectedTaskId);
            if (idx >= 0 && project.tasks[idx].level > 0) {
                project.tasks[idx].level--;
                updateWBS();
                calculateSchedule();
                renderProject();
            }
        }
    }

    function addMilestone() {
        const milestone = {
            id: project.nextId++,
            wbs: '',
            name: 'Milestone',
            duration: 0,
            start: null,
            finish: null,
            predecessor: selectedTaskId || '',
            level: 1,
            isSummary: false,
            expanded: true
        };
        project.tasks.push(milestone);
        updateWBS();
        calculateSchedule();
        renderProject();
    }

    // Update WBS codes and summary flags
    function updateWBS() {
        let counters = [0, 0, 0, 0];
        project.tasks.forEach(task => {
            counters[task.level]++;
            for (let i = task.level + 1; i < counters.length; i++) counters[i] = 0;
            task.wbs = counters.slice(0, task.level + 1).join('.') + (task.level === 0 ? '.0' : '');
            // Set isSummary if next task is deeper
            const idx = project.tasks.indexOf(task);
            const next = project.tasks[idx + 1];
            task.isSummary = !!(next && next.level > task.level);
        });
    }

    // Zoom functions
    function zoomIn() {
        if (zoomLevel < 50) {
            zoomLevel += 5;
            renderGanttChart();
        }
    }

    function zoomOut() {
        if (zoomLevel > 10) {
            zoomLevel -= 5;
            renderGanttChart();
        }
    }

    // Project management
    function showNewProjectModal() {
        document.getElementById('newProjectModal').classList.add('active');
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
    }

    function createProject() {
        const name = document.getElementById('projectName').value;
        const startDate = document.getElementById('projectStartDate').value;
        if (name && startDate) {
            project = {
                name: name,
                startDate: new Date(startDate),
                tasks: [],
                nextId: 1
            };
            renderProject();
            closeModal('newProjectModal');
        }
    }

    function saveProject() {
        const dataStr = JSON.stringify(project, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
        const exportFileDefaultName = project.name.replace(/\s+/g, '_') + '.json';
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    }

    function loadProject() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const loadedProject = JSON.parse(event.target.result);
                    project = loadedProject;
                    project.startDate = new Date(project.startDate);
                    project.tasks.forEach(task => {
                        if (task.start) task.start = new Date(task.start);
                        if (task.finish) task.finish = new Date(task.finish);
                    });
                    updateWBS();
                    calculateSchedule();
                    renderProject();
                } catch (error) {
                    alert('Error loading project file');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    // Utility functions
    function formatDate(date) {
        if (!date) return '';
        const d = new Date(date);
        return `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
    }

    function getDaysDiff(date1, date2) {
        const d1 = new Date(date1);
        const d2 = new Date(date2);
        return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
    }

    function getMonthName(month) {
        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return months[month];
    }

    // Initialize on load
    window.onload = init;
</script>
// ...existing code...
